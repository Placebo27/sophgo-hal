#![no_std]
#![feature(naked_functions, asm_const)]

pub use sophgo_rom_rt_macros::entry;

use base_address::Static;

/// Peripherals available on ROM start.
pub struct Peripherals {
    /// Universal Asynchronous Receiver/Transmitter 0.
    pub uart0: sophgo_hal::UART<Static<0x04140000>>,
}

#[cfg(target_arch = "riscv64")]
use core::arch::asm;

#[cfg(target_arch = "riscv64")]
const LEN_STACK: usize = 1 * 1024;

/// RISC-V program stack.
///
/// In standard RISC-V ABI specification, the stack grows downward and
/// the stack pointer is always kept 16-byte aligned.
#[repr(align(16))]
pub struct Stack<const N: usize>([u8; N]);

#[cfg(target_arch = "riscv64")]
#[naked]
#[link_section = ".text.entry"]
#[export_name = "_start"]
unsafe extern "C" fn entry() -> ! {
    #[link_section = ".bss.uninit"]
    static mut STACK: Stack<LEN_STACK> = Stack([0; LEN_STACK]);
    asm!(
        ".option push
        .option arch, -c
            j       1f
        .option pop",
        ".word   0",  // resvered
        ".word   0",  // BL2 MSID
        ".word   0",  // BL2 version
        ".word   0",  //
        ".word   0",
        ".word   0",
        ".word   0",
        "1:  la      sp, {stack}
            li      t0, {hart_stack_size}
            add     sp, sp, t0",
        "	la  	t1, sbss
        	la   	t2, ebss
    	1:  bgeu 	t1, t2, 1f
        	sd   	zero, 0(t1) 
        	addi 	t1, t1, 8 
        	j    	1b
    	1:",
        "   call    {main}",
        stack = sym STACK,
        hart_stack_size = const LEN_STACK,
        main = sym main,
        options(noreturn)
    )
}

#[cfg(target_arch = "riscv64")]
extern "Rust" {
    // This symbol is generated by `#[entry]` macro
    fn main() -> !;
}
